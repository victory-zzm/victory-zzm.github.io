<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>ES6语法总结 | aichihaidilao</title><meta name="keywords" content="JS"><meta name="author" content="Tom"><meta name="copyright" content="Tom"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1. 变量的结构赋值1.1 数组的解构赋值ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构；  以前为变量赋值，只能直接赋值  123let a &#x3D; 1;let b &#x3D; 2;let c &#x3D; 3;   ES6解构赋值的形式如下：  12345678let [a, b ,c] &#x3D; [1,2,3];&#x2F;&#x2F; 上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值;let [h">
<meta property="og:type" content="article">
<meta property="og:title" content="ES6语法总结">
<meta property="og:url" content="http://example.com/2021/10/11/ES6%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="aichihaidilao">
<meta property="og:description" content="1. 变量的结构赋值1.1 数组的解构赋值ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构；  以前为变量赋值，只能直接赋值  123let a &#x3D; 1;let b &#x3D; 2;let c &#x3D; 3;   ES6解构赋值的形式如下：  12345678let [a, b ,c] &#x3D; [1,2,3];&#x2F;&#x2F; 上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值;let [h">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/victory-zzm/CDN/img/default_bg2.png">
<meta property="article:published_time" content="2021-10-11T00:28:55.000Z">
<meta property="article:modified_time" content="2021-10-30T09:43:29.547Z">
<meta property="article:author" content="Tom">
<meta property="article:tag" content="JS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/victory-zzm/CDN/img/default_bg2.png"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="http://example.com/2021/10/11/ES6%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Tom","link":"链接: ","source":"来源: aichihaidilao","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'ES6语法总结',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-10-30 17:43:29'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><link rel="stylesheet" href="APlayer.min.css"><div id="aplayer"></div><script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js" async></script><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/victory-zzm/CDN/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">36</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fas fa-comments"></i><span> 说说</span></a></li><li><a class="site-page child" href="/galleryGroup/"><i class="fa-fw fas fa-galleryGroup"></i><span> 图库</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/victory-zzm/CDN/img/default_bg2.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">aichihaidilao</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fas fa-comments"></i><span> 说说</span></a></li><li><a class="site-page child" href="/galleryGroup/"><i class="fa-fw fas fa-galleryGroup"></i><span> 图库</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">ES6语法总结<a class="post-edit-link" href="null_posts/ES6语法总结.md" title="编辑" target="_blank"><i class="fas fa-pencil-alt"></i></a></h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-10-11T00:28:55.000Z" title="发表于 2021-10-11 08:28:55">2021-10-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-10-30T09:43:29.547Z" title="更新于 2021-10-30 17:43:29">2021-10-30</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="ES6语法总结"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="1-变量的结构赋值"><a href="#1-变量的结构赋值" class="headerlink" title="1. 变量的结构赋值"></a>1. 变量的结构赋值</h1><h2 id="1-1-数组的解构赋值"><a href="#1-1-数组的解构赋值" class="headerlink" title="1.1 数组的解构赋值"></a>1.1 数组的解构赋值</h2><p>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构；</p>
<ul>
<li>以前为变量赋值，只能直接赋值</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> c = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>ES6解构赋值的形式如下：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b ,c] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="comment">// 上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值;</span></span><br><span class="line"><span class="keyword">let</span> [head, ...tail] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">head <span class="comment">// 1</span></span><br><span class="line">tail <span class="comment">// [2, 3, 4]</span></span><br><span class="line"><span class="keyword">let</span> [foo] = [];</span><br><span class="line"><span class="keyword">let</span> [bar, foo] = [<span class="number">1</span>];</span><br><span class="line"><span class="comment">// 以上两种情况都属于解构不成功，foo的值都会等于undefined。</span></span><br></pre></td></tr></table></figure>

<ul>
<li>不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [x, y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// 2</span></span><br><span class="line"><span class="keyword">let</span> [a, [b], d] = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>];</span><br><span class="line">a <span class="comment">// 1</span></span><br><span class="line">b <span class="comment">// 2</span></span><br><span class="line">d <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<h2 id="1-2-对象的解构赋值"><a href="#1-2-对象的解构赋值" class="headerlink" title="1.2 对象的解构赋值"></a>1.2 对象的解构赋值</h2><p>对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; bar, foo &#125; = &#123; <span class="attr">foo</span>: <span class="string">&#x27;aaa&#x27;</span>, <span class="attr">bar</span>: <span class="string">&#x27;bbb&#x27;</span> &#125;;</span><br><span class="line">foo <span class="comment">// &quot;aaa&quot;</span></span><br><span class="line">bar <span class="comment">// &quot;bbb&quot;</span></span><br><span class="line"><span class="comment">// 解构失败的情况 不存在当前的属性名</span></span><br><span class="line"><span class="keyword">let</span> &#123; baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">&#x27;aaa&#x27;</span>, <span class="attr">bar</span>: <span class="string">&#x27;bbb&#x27;</span> &#125;;</span><br><span class="line">baz <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<ul>
<li>对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量</span></span><br><span class="line">    <span class="keyword">let</span> &#123;log&#125; = <span class="built_in">console</span>; <span class="comment">// 将console.log赋值到log变量</span></span><br><span class="line">    log(<span class="string">&#x27;woshishagua&#x27;</span>);</span><br><span class="line">    <span class="comment">// log(a,b,c);</span></span><br><span class="line">    <span class="keyword">let</span> &#123; sin, cos &#125; = <span class="built_in">Math</span>; <span class="comment">// 将Math对象的正弦、余弦三个方法，赋值到对应的变量上</span></span><br><span class="line">    log(sin,cos);</span><br></pre></td></tr></table></figure>

<ul>
<li>对象的解构赋值是下面形式的简写</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">foo</span>: foo, <span class="attr">bar</span>: bar &#125; = &#123; <span class="attr">foo</span>: <span class="string">&#x27;aaa&#x27;</span>, <span class="attr">bar</span>: <span class="string">&#x27;bbb&#x27;</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">foo1</span>: baz1 &#125; = &#123; <span class="attr">foo1</span>: <span class="string">&#x27;aaa&#x27;</span>, <span class="attr">baz1</span>: <span class="string">&#x27;bbb&#x27;</span> &#125;;</span><br><span class="line">baz1 <span class="comment">// &quot;aaa&quot;</span></span><br><span class="line">foo1 <span class="comment">// error: foo1 is not defined</span></span><br><span class="line">log(baz1,foo1);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>foo1</code>是匹配的模式，<code>baz1</code>才是变量。真正被赋值的是变量<code>baz1</code>，而不是模式<code>foo</code>1;</p>
<ul>
<li><p>对象解构赋值也可以嵌套解构</p>
</li>
<li><p>注意点</p>
<ol>
<li>如果要将一个已经声明的变量用于解构赋值，必须非常小心</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误的写法</span></span><br><span class="line"><span class="keyword">let</span> x;</span><br><span class="line">&#123;x&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="comment">// SyntaxError: syntax error</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>字符串的解构赋值</li>
</ol>
<ul>
<li>字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [a, b, c, d, e] = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">a <span class="comment">// &quot;h&quot;</span></span><br><span class="line">b <span class="comment">// &quot;e&quot;</span></span><br><span class="line">c <span class="comment">// &quot;l&quot;</span></span><br><span class="line">d <span class="comment">// &quot;l&quot;</span></span><br><span class="line">e <span class="comment">// &quot;o&quot;</span></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">length</span>:len&#125; = <span class="string">&#x27;hello&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="1-3-解构赋值的作用"><a href="#1-3-解构赋值的作用" class="headerlink" title="1.3 解构赋值的作用"></a>1.3 解构赋值的作用</h2><ol>
<li>交换变量的值</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解构赋值用于 交换变量的值</span></span><br><span class="line"><span class="keyword">let</span> changeX = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> changeY = <span class="number">2</span>;</span><br><span class="line">[changeX,changeY] = [changeY,changeX];<span class="comment">// 直接交换两个值</span></span><br><span class="line">log(changeX,changeY);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>从函数中返回多个值</li>
</ol>
<p>函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  从函数返回多个值,以数组的方式返回</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">returnArray</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> [one1,two1,three1] = returnArray();</span><br><span class="line"><span class="built_in">console</span>.log(one1,two1,three1); </span><br><span class="line"><span class="comment">//  从函数返回多个值,以对象的方式返回</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">returnObject</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">age2</span>:<span class="number">18</span>,</span><br><span class="line">    <span class="attr">height2</span>:<span class="number">188</span>,</span><br><span class="line">    <span class="attr">name2</span>:<span class="string">&#x27;李世民&#x27;</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> &#123;age2,height2,name2&#125; = returnObject();</span><br><span class="line"><span class="built_in">console</span>.log(returnObject());</span><br><span class="line"><span class="built_in">console</span>.log(age2,height2,name2);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>函数参数的定义</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数参数的定义</span></span><br><span class="line"><span class="comment">// 解构赋值可以方便地将一组参数与变量名对应起来</span></span><br><span class="line"><span class="comment">// 参数是一组有次序的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">oneFunction</span>(<span class="params">[xx1,yy1,zz1]</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(xx1,yy1,zz1);</span><br><span class="line">&#125;</span><br><span class="line">oneFunction([<span class="number">111</span>,<span class="number">222</span>,<span class="number">333</span>]);</span><br><span class="line"><span class="comment">// 参数是一组无次序的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">twoFunction</span>(<span class="params">&#123;xx,yy,zz&#125;</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(xx,yy,zz);</span><br><span class="line">&#125;</span><br><span class="line">twoFunction(&#123;<span class="attr">xx</span>:<span class="string">&#x27;憨批&#x27;</span>,<span class="attr">yy</span>:<span class="number">18</span>,<span class="attr">zz</span>:<span class="string">&#x27;爱吃海底捞&#x27;</span>&#125;);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>提取JSON字符串</p>
<p>解构赋值对提取 JSON 对象中的数据，尤其有用</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对JSON对象进行解构赋值</span></span><br><span class="line"><span class="keyword">let</span> jsonData = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="number">42</span>,</span><br><span class="line">  <span class="attr">status</span>: <span class="string">&quot;OK&quot;</span>,</span><br><span class="line">  <span class="attr">data</span>: [<span class="number">867</span>, <span class="number">5309</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; id, status, <span class="attr">data</span>: number &#125; = jsonData;</span><br><span class="line"><span class="built_in">console</span>.log(id, status, number);</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>遍历map()结构</p>
<p>Map 结构原生支持 Iterator 接口，配合变量的解构赋值，获取键名和键值就非常方便；</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="string">&#x27;first&#x27;</span>, <span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">map.set(<span class="string">&#x27;second&#x27;</span>, <span class="string">&#x27;world&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key + <span class="string">&quot; is &quot;</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// first is hello</span></span><br><span class="line"><span class="comment">// second is world</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li><p>输入模块的指定方法</p>
<p>加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; SourceMapConsumer, SourceNode &#125; = <span class="built_in">require</span>(<span class="string">&quot;source-map&quot;</span>);</span><br></pre></td></tr></table></figure>

<h1 id="2-运算符的扩展"><a href="#2-运算符的扩展" class="headerlink" title="2. 运算符的扩展"></a>2. 运算符的扩展</h1><h2 id="2-1-指数运算符【-】："><a href="#2-1-指数运算符【-】：" class="headerlink" title="2.1 指数运算符【**】："></a>2.1 指数运算符【**】：</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>**<span class="number">8</span>);  <span class="comment">//256</span></span><br></pre></td></tr></table></figure>

<ul>
<li>这个运算符的一个特点是右结合，而不是常见的左结合。多个指数运算符连用时，是从最右边开始计算的；</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(2**3**2); //512 相当于 2 ** (3 ** 2)</span><br></pre></td></tr></table></figure>

<ul>
<li>指数运算符可以与等号结合，形成一个新的赋值运算符：（**=）</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">3</span>;</span><br><span class="line">a **= <span class="number">2</span>; <span class="comment">// 相当于a*a;</span></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 9</span></span><br></pre></td></tr></table></figure>

<h2 id="2-2-链判断运算符【-】"><a href="#2-2-链判断运算符【-】" class="headerlink" title="2.2 链判断运算符【?.】"></a>2.2 链判断运算符【?.】</h2><p>使用举例：读取某个对象内的某个属性，比如，读取<code>message.body.user.firstName</code>这个属性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误的写法</span></span><br><span class="line"><span class="keyword">const</span>  firstName = message.body.user.firstName || <span class="string">&#x27;default&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确的写法</span></span><br><span class="line"><span class="keyword">const</span> firstName = (message</span><br><span class="line">  &amp;&amp; message.body</span><br><span class="line">  &amp;&amp; message.body.user</span><br><span class="line">  &amp;&amp; message.body.user.firstName) || <span class="string">&#x27;default&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链判断符的写法</span></span><br><span class="line"><span class="keyword">const</span> firstName = message?.body?.user?.firstName || <span class="string">&#x27;default&#x27;</span>;</span><br><span class="line"><span class="comment">//上面代码使用了?.运算符，直接在链式调用的时候判断</span></span><br><span class="line"><span class="comment">//左侧的对象是否为null或undefined</span></span><br><span class="line"><span class="comment">//如果是的，就不再往下运算，而是返回undefined。</span></span><br></pre></td></tr></table></figure>

<p>链判断运算符<code>?.</code>有三种写法。</p>
<ul>
<li><code>obj?.prop</code> // 对象属性是否存在</li>
<li><code>obj?.[expr]</code> // 同上</li>
<li><code>func?.(...args)</code> // 函数或对象方法是否存在</li>
</ul>
<h2 id="2-3-NULL-判断符【-】"><a href="#2-3-NULL-判断符【-】" class="headerlink" title="2.3 NULL 判断符【??】"></a>2.3 NULL 判断符【??】</h2><p>读取对象属性的时候，如果某个属性的值是<code>null</code>或<code>undefined</code>，有时候需要为它们指定默认值。常见做法是通过<code>||</code>运算符指定默认值；</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> headerText = response.settings.headerText || <span class="string">&#x27;Hello, world!&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> animationDuration = response.settings.animationDuration || <span class="number">300</span>;</span><br><span class="line"><span class="keyword">const</span> showSplashScreen = response.settings.showSplashScreen || <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<p>上面的三行代码都通过<code>||</code>运算符指定默认值，但是这样写是错的。开发者的原意是，只要属性的值为<code>null</code>或<code>undefined</code>，默认值就会生效，但是属性的值如果为空字符串或<code>false</code>或<code>0</code>，默认值也会生效；</p>
<p><a target="_blank" rel="noopener" href="https://github.com/tc39/proposal-nullish-coalescing">ES2020</a> 引入了一个新的 Null 判断运算符<code>??</code>。它的行为类似<code>||</code>，但是只有运算符左侧的值为<code>null</code>或<code>undefined</code>时，才会返回右侧的值;</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> headerText = response.settings.headerText ?? <span class="string">&#x27;Hello, world!&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> animationDuration = response.settings.animationDuration ?? <span class="number">300</span>;</span><br><span class="line"><span class="keyword">const</span> showSplashScreen = response.settings.showSplashScreen ?? <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<p>上面代码中，默认值只有在左侧属性值为<code>null</code>或<code>undefined</code>时，才会生效，这个运算符的一个目的，就是跟链判断运算符<code>?.</code>配合使用，为<code>null</code>或<code>undefined</code>的值设置默认值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> animationDuration = response.settings?.animationDuration ?? <span class="number">300</span>;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong> :  ?? 是逻辑运算，在使用的时候记得添加小括号()，防止优先级的问题；</p>
<h2 id="2-4-逻辑赋值运算符"><a href="#2-4-逻辑赋值运算符" class="headerlink" title="2.4  逻辑赋值运算符"></a>2.4  逻辑赋值运算符</h2><p>即是将逻辑运算与赋值运算相结合</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 或赋值运算符</span></span><br><span class="line">x ||= y</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">x || (x = y)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与赋值运算符</span></span><br><span class="line">x &amp;&amp;= y</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">x &amp;&amp; (x = y)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Null 赋值运算符</span></span><br><span class="line">x ??= y</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">x ?? (x = y)</span><br></pre></td></tr></table></figure>

<p>使用举例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 老的写法</span></span><br><span class="line">user.id = user.id || <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 新的写法</span></span><br><span class="line">user.id ||= <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params">opts</span>) </span>&#123;</span><br><span class="line">  opts.foo ??= <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line">  opts.baz ??= <span class="string">&#x27;qux&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-Symbol"><a href="#3-Symbol" class="headerlink" title="3. Symbol"></a>3. Symbol</h1><p>ES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入<code>Symbol</code>的原因;</p>
<p>ES6 引入了一种新的<strong>原始数据类型<code>Symbol</code>，表示独一无二的值</strong>。它是 JavaScript 语言的第七种数据类型，前六种是：<code>undefined</code>、<code>null</code>、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）;</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有参数的情况</span></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line">s1 === s2 <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有参数的情况</span></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"></span><br><span class="line">s1 === s2 <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h2 id="3-1-Symbol-prototype-description-创建Symbol时添加一个描述"><a href="#3-1-Symbol-prototype-description-创建Symbol时添加一个描述" class="headerlink" title="3.1 Symbol.prototype.description(创建Symbol时添加一个描述)"></a>3.1 Symbol.prototype.description(创建Symbol时添加一个描述)</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sym = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);  <span class="comment">// sym的描述就是字符串foo</span></span><br></pre></td></tr></table></figure>

<p>新增的一个实例属性<code>description</code>，直接返回 Symbol 的描述，如下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sym = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">sym.description <span class="comment">// &quot;foo&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="3-2-作为属性名的Symbol（防止重写）"><a href="#3-2-作为属性名的Symbol（防止重写）" class="headerlink" title="3.2 作为属性名的Symbol（防止重写）"></a>3.2 作为属性名的Symbol（防止重写）</h2><p>能防止某一个键被不小心改写或覆盖；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mySymbol = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种写法</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;&#125;;</span><br><span class="line">a[mySymbol] = <span class="string">&#x27;Hello!&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种写法</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  [mySymbol]: <span class="string">&#x27;Hello!&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三种写法</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(a, mySymbol, &#123; <span class="attr">value</span>: <span class="string">&#x27;Hello!&#x27;</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上写法都得到同样结果</span></span><br><span class="line">a[mySymbol] <span class="comment">// &quot;Hello!&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>，Symbol 值作为对象属性名时，不能用点运算符</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mySymbol = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> a = &#123;&#125;;</span><br><span class="line">a.mySymbol = <span class="string">&#x27;Hello!&#x27;</span>;</span><br><span class="line">a[mySymbol] <span class="comment">// undefined</span></span><br><span class="line">a[<span class="string">&#x27;mySymbol&#x27;</span>] <span class="comment">// &quot;Hello!&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，因为点运算符后面总是字符串，所以不会读取<code>mySymbol</code>作为标识名所指代的那个值，导致<code>a</code>的属性名实际上是一个字符串，而不是一个 Symbol 值。</p>
<h2 id="3-3-Symbol作为属性名时，不会被for…in、for…of遍历"><a href="#3-3-Symbol作为属性名时，不会被for…in、for…of遍历" class="headerlink" title="3.3 Symbol作为属性名时，不会被for…in、for…of遍历"></a>3.3 Symbol作为属性名时，不会被for…in、for…of遍历</h2><p>作为对象当属性名时，它也不是私有属性，具有<code>Object.getOwnPropertySymbols()</code>方法，可以获取指定对象的所有 Symbol 属性名。该方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> a = <span class="built_in">Symbol</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">Symbol</span>(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"></span><br><span class="line">obj[a] = <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line">obj[b] = <span class="string">&#x27;World&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> objectSymbols = <span class="built_in">Object</span>.getOwnPropertySymbols(obj);</span><br><span class="line"></span><br><span class="line">objectSymbols</span><br><span class="line"><span class="comment">// [Symbol(a), Symbol(b)]</span></span><br></pre></td></tr></table></figure>

<h1 id="4-Set和Map数据结构"><a href="#4-Set和Map数据结构" class="headerlink" title="4. Set和Map数据结构"></a>4. Set和Map数据结构</h1><h2 id="4-1-Set结构（可比作集合）"><a href="#4-1-Set结构（可比作集合）" class="headerlink" title="4.1 Set结构（可比作集合）"></a>4.1 Set结构（可比作集合）</h2><ul>
<li>它与数组类似，但是它的成员的值都是唯一的，没有重复的值，在判断值是否相等时采用的是精确相等运算符（===）,唯一区别就是NaN会认为相等于自身；</li>
<li><code>Set</code>本身是一个构造函数，用来生成 Set 数据结构。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line">arr.forEach(<span class="function"><span class="params">x</span>=&gt;</span>s.add(x)); <span class="comment">// 通过add()方法向set结构中添加成员</span></span><br><span class="line"><span class="built_in">console</span>.log(s);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">of</span> s )&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(i); <span class="comment">// 1,2,3,4,5,6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>set结构可以接收一个函数作为参数用来初始化；</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s2 = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(s2); <span class="comment">// 1,3,5,7,9</span></span><br><span class="line"><span class="built_in">console</span>.log(s2.size); <span class="comment">// 长度为5</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>set结构可以除去数组中重复的元素</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line"><span class="comment">// 注意此处的...运算符不可省略</span></span><br><span class="line">arr = [...new <span class="built_in">Set</span>(arr)];</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>set结构可以除去字符串中重复的字符</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[...new <span class="built_in">Set</span>(<span class="string">&#x27;ababbc&#x27;</span>)]; <span class="comment">// 注意此时是一个 字符串数组[&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;];</span></span><br><span class="line">[...new <span class="built_in">Set</span>(<span class="string">&#x27;ababbc&#x27;</span>)].join(<span class="string">&#x27;&#x27;</span>); <span class="comment">// 结果是将字符串ababbc转为没有重复字符的字符串abc</span></span><br></pre></td></tr></table></figure>

<h2 id="4-2-set结构的属性和方法"><a href="#4-2-set结构的属性和方法" class="headerlink" title="4.2 set结构的属性和方法"></a>4.2 set结构的属性和方法</h2><ol>
<li><p>Set结构实例有如下属性</p>
<ul>
<li>Set.prototype.constructor: 构造函数，默认就是Set函数</li>
<li>Set.prototype.size: 返回Set实例的成员总数</li>
</ul>
</li>
<li><p>Set实例方法一：操作方法（用于操作数据）</p>
<ul>
<li>Set.prototype.add(value): 添加某个值，返回Set结构本身；</li>
<li>Set.prototype.delete(value): 删除某个值，返回一个布尔值，表示是否成功删除；</li>
<li>Set.prototype.has(value): 返回一个布尔值，表示该值是否是当前Set实例的一个成员；</li>
<li>Set.prototype.clear(): 清空当前实例的所有成员；</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// set实例方法操作展示</span></span><br><span class="line"><span class="keyword">let</span> oneSet = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">oneSet.add(<span class="number">1</span>).add(<span class="number">2</span>).add(<span class="number">8</span>).add(<span class="number">1</span>); <span class="comment">//注意此处1被添加了两次</span></span><br><span class="line"><span class="built_in">console</span>.log(oneSet); <span class="comment">// 1,2,8</span></span><br><span class="line">oneSet.delete(<span class="number">8</span>);</span><br><span class="line"><span class="built_in">console</span>.log(oneSet);</span><br><span class="line"><span class="built_in">console</span>.log(oneSet.has(<span class="number">3</span>));<span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(oneSet.clear()); <span class="comment">//undefined 因为被删除完毕</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Array.from(setItem) 方法可以将Set结构转为数组与(return <strong>[…new Set(array)]</strong>;)类似</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arrOne = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> setItem = <span class="keyword">new</span> <span class="built_in">Set</span>(arrOne);</span><br><span class="line"><span class="keyword">let</span> arrNew = <span class="built_in">Array</span>.from(setItem);</span><br><span class="line"><span class="built_in">console</span>.log(arrNew);</span><br></pre></td></tr></table></figure>

<p>这就提供了除去数组中重复元素的方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dedupe</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(array)); <span class="comment">//等同于下面</span></span><br><span class="line">  <span class="comment">// return [...new Set(array)];</span></span><br><span class="line">&#125;</span><br><span class="line">dedupe([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure></li>
<li><p>Set实例方法二：遍历方法，用于遍历数据</p>
<ul>
<li>Set.prototype.keys(): 返回键名的遍历器</li>
<li>Set.prototype.values(): 返回键值的遍历器</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> set.values()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item); <span class="comment">// red green blue</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Set.prototype.entries(): 返回键值对的遍历器</p>
</li>
<li><p>set.prototype.forEach(): 使用回调函数遍历每一个成员</p>
<ul>
<li>Set 结构的实例与数组一样，也拥有<code>forEach</code>方法，用于对每个成员执行某种操作，没有返回值;</li>
<li><code>forEach</code>方法还可以有第二个参数，表示绑定处理函数内部的<code>this</code>对象;</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> setTwo = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&#x27;red&#x27;</span>,<span class="string">&#x27;green&#x27;</span>,<span class="string">&#x27;blue&#x27;</span>]);</span><br><span class="line">setTwo.forEach(<span class="function">(<span class="params">value,key</span>)=&gt;</span><span class="built_in">console</span>.log(value+<span class="string">&#x27;:&#x27;</span>+key));</span><br><span class="line"><span class="comment">// red : red</span></span><br><span class="line"><span class="comment">// green : green</span></span><br><span class="line"><span class="comment">// blue : blue</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>Set的遍历顺序就是插入顺序；</p>
<ul>
<li>Set结构的实例默认可遍历，它的默认遍历器生成函数就是它的values方法；</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set</span>.prototype[<span class="built_in">Symbol</span>.iterator] === <span class="built_in">Set</span>.prototype.values; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>这就意味着可以省略values方法，直接用for…of循环遍历Set</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> setTwo = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&#x27;red&#x27;</span>,<span class="string">&#x27;green&#x27;</span>,<span class="string">&#x27;blue&#x27;</span>]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> x <span class="keyword">of</span> setTwo)&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(x); <span class="comment">// red green blue</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>遍历的运用</p>
<p>扩展运算符（<code>...</code>）内部使用<code>for...of</code>循环，所以也可以用于 Set 结构，可用于出去重复的元素</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let setTwo = new Set([&#x27;red&#x27;,&#x27;green&#x27;,&#x27;blue&#x27;]);</span><br><span class="line">// 扩展运算符的应用</span><br><span class="line">console.log([...setTwo]);</span><br><span class="line">let setThree = new Set([1,2,3,4,1,2,3,4]);</span><br><span class="line">console.log([...setThree]); // 1,2,3,4 除去重复的元素</span><br></pre></td></tr></table></figure>

<p>​        并且数组中的map，filter方法也可以间接用于Set结构；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set1 = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]);</span><br><span class="line"><span class="built_in">console</span>.log([...set1].map(<span class="function"><span class="params">x</span>=&gt;</span>&#123;<span class="keyword">return</span> x*<span class="number">2</span>;&#125;)); <span class="comment">// 2,4,6,8,10</span></span><br><span class="line"><span class="keyword">let</span> set2 = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>]);</span><br><span class="line"><span class="built_in">console</span>.log([...set2].filter(<span class="function"><span class="params">x</span>=&gt;</span>&#123;<span class="keyword">return</span> x&gt;=<span class="number">7</span>&#125;)); <span class="comment">// 9,8,7</span></span><br></pre></td></tr></table></figure>

<p>​        使用Set结构实现并集，交集，和差集；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set1 = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]);</span><br><span class="line"><span class="keyword">let</span> set2 = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]);</span><br><span class="line"><span class="comment">// 并集</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Set</span>([...set1,...set2])); <span class="comment">// 1,2,3,4,5,6,7,8,9</span></span><br><span class="line"><span class="comment">// 交集</span></span><br><span class="line"><span class="built_in">console</span>.log([...set1].filter(<span class="function"><span class="params">x</span>=&gt;</span>&#123;<span class="keyword">return</span> set2.has(x)&#125;)); <span class="comment">// 4,5,6</span></span><br><span class="line"><span class="comment">// 差集</span></span><br><span class="line"><span class="built_in">console</span>.log([...set1].filter(<span class="function"><span class="params">x</span>=&gt;</span>&#123;<span class="keyword">return</span> !set2.has(x)&#125;)); <span class="comment">//1,2,3</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="4-3-WeakSet-结构与-Set-类似，也是不重复的值的集合"><a href="#4-3-WeakSet-结构与-Set-类似，也是不重复的值的集合" class="headerlink" title="4.3 WeakSet 结构与 Set 类似，也是不重复的值的集合"></a>4.3 WeakSet 结构与 Set 类似，也是不重复的值的集合</h2><ul>
<li>WeakSet 的成员只能是对象，而不能是其他类型的值</li>
</ul>
<ol>
<li><p>WeakSet结构有三个方法</p>
<p>WeakSet.prototype.add(value): 向实例中添加一个新成员</p>
<p>WeakSet.prototype.delete(value): 清除实例中的指定成员</p>
<p>WeakSet.prototype.has(value): 返回一个布尔值，表示某个值是否在实例中</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>();</span><br><span class="line"><span class="keyword">const</span> windows = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;窗户&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line">ws.add(windows);</span><br><span class="line">ws.add(person);</span><br><span class="line"><span class="built_in">console</span>.log(ws.has(windows)); <span class="comment">// true</span></span><br><span class="line">ws.delete(windows);</span><br><span class="line"><span class="built_in">console</span>.log(ws.has(windows)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p><strong>WeakSet的使用注意</strong></p>
<p>WeakSet 不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保证成员的存在，很可能刚刚遍历结束，成员就取不到了。WeakSet 的一个用处，是储存 DOM 节点，而不用担心这些节点从文档移除时，会引发内存泄漏</p>
</li>
</ol>
<h2 id="4-4-Map数据结构"><a href="#4-4-Map数据结构" class="headerlink" title="4.4 Map数据结构"></a>4.4 Map数据结构</h2><p>Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适</p>
<h3 id="4-4-1Map属性和操作方法"><a href="#4-4-1Map属性和操作方法" class="headerlink" title="4.4.1Map属性和操作方法"></a>4.4.1Map属性和操作方法</h3><ol>
<li>size属性，返回Map数据结构的成员总数；</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map1 = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map1.set(<span class="string">&#x27;foo&#x27;</span>,<span class="literal">true</span>);</span><br><span class="line">map1.set(<span class="string">&#x27;person&#x27;</span>,<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">console</span>.log(map1.size); <span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>Map.prototype.set(key,value); </li>
</ol>
<p><code>set</code>方法设置键名<code>key</code>对应的键值为<code>value</code>，然后返回整个 Map 结构。如果<code>key</code>已经有值，则键值会被更新，否则就新生成该键;</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">m.set(<span class="string">&#x27;edition&#x27;</span>, <span class="number">6</span>)        <span class="comment">// 键是字符串</span></span><br><span class="line">m.set(<span class="number">262</span>, <span class="string">&#x27;standard&#x27;</span>)     <span class="comment">// 键是数值</span></span><br><span class="line">m.set(<span class="literal">undefined</span>, <span class="string">&#x27;nah&#x27;</span>)    <span class="comment">// 键是 undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(m);</span><br></pre></td></tr></table></figure>

<p>另外可以通过链式调用的方式来创建新的键：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">  .set(<span class="string">&#x27;person&#x27;</span>,<span class="string">&#x27;张三&#x27;</span>)</span><br><span class="line">  .set(<span class="string">&#x27;money&#x27;</span>,<span class="number">1800</span>)</span><br><span class="line">  .set(<span class="number">18</span>,<span class="string">&#x27;李世民&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(m);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>Map.prototype.get(key);</p>
<p>get()方法用来读取响应的值，如果找不到key，就返回undefined;</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">  .set(<span class="string">&#x27;person&#x27;</span>,<span class="string">&#x27;张三&#x27;</span>)</span><br><span class="line">  .set(<span class="string">&#x27;money&#x27;</span>,<span class="number">1800</span>)</span><br><span class="line">  .set(<span class="number">18</span>,<span class="string">&#x27;李世民&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(m.get(<span class="number">18</span>));</span><br><span class="line"><span class="built_in">console</span>.log(m.get(<span class="string">&#x27;money&#x27;</span>))</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>Map.prototype.has(key);</p>
<p>has()方法返回一个布尔值，表示某个键是否在当前的对象中</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">  .set(<span class="string">&#x27;person&#x27;</span>,<span class="string">&#x27;张三&#x27;</span>)</span><br><span class="line">  .set(<span class="string">&#x27;money&#x27;</span>,<span class="number">1800</span>)</span><br><span class="line">  .set(<span class="number">18</span>,<span class="string">&#x27;李世民&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(m.has(<span class="string">&#x27;money&#x27;</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li>
<li><p>Map.prototype.delete(key);</p>
<p>表示删除某个键，删除成功返回true，删除失败返回false;</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(m.delete(<span class="string">&#x27;money&#x27;</span>)); <span class="comment">//true</span></span><br></pre></td></tr></table></figure></li>
<li><p>Map.prototype.clear(); 清空所有元素，没有返回值；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m.cleat();</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="4-4-2-遍历方法"><a href="#4-4-2-遍历方法" class="headerlink" title="4.4.2 遍历方法"></a>4.4.2 遍历方法</h3><ol>
<li>Map.prototype.keys(): 返回键名的遍历器</li>
<li>Map.prototype.values(): 返回键值的遍历器</li>
<li>Map.prototype.entries(): 返回所有成员的遍历器</li>
<li>Map.prototype.forEach(): 遍历Map的所有成员</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">  .set(<span class="string">&#x27;person&#x27;</span>,<span class="string">&#x27;张三&#x27;</span>)</span><br><span class="line">  .set(<span class="string">&#x27;money&#x27;</span>,<span class="number">1800</span>)</span><br><span class="line">  .set(<span class="number">18</span>,<span class="string">&#x27;李世民&#x27;</span>)</span><br><span class="line">  .set(<span class="string">&#x27;stock&#x27;</span>,<span class="string">&#x27;股票&#x27;</span>)</span><br><span class="line">  .set(<span class="string">&#x27;company&#x27;</span>,<span class="string">&#x27;恒瑞医药&#x27;</span>)</span><br><span class="line">  .set(<span class="string">&#x27;fund&#x27;</span>,<span class="string">&#x27;中概互联网&#x27;</span>);</span><br><span class="line"><span class="comment">// console.log(m.keys());</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">of</span> m.keys())&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> value <span class="keyword">of</span> m.values())&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> m.entries())&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item[<span class="number">0</span>],item[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">m.forEach(<span class="function">(<span class="params">key,value</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key,value);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>注意：Map实例的遍历顺序就是插入顺序；</p>
<ul>
<li>Map结构转为数组结构使用扩展运算符</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="number">1</span>, <span class="string">&#x27;one&#x27;</span>],</span><br><span class="line">  [<span class="number">2</span>, <span class="string">&#x27;two&#x27;</span>],</span><br><span class="line">  [<span class="number">3</span>, <span class="string">&#x27;three&#x27;</span>],</span><br><span class="line">]);</span><br><span class="line"><span class="built_in">console</span>.log([...map.values()]); <span class="comment">// [&#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;]</span></span><br><span class="line"><span class="built_in">console</span>.log([...map.keys()]); <span class="comment">// [1, 2, 3]</span></span><br><span class="line"><span class="built_in">console</span>.log([...map.entries()]); <span class="comment">// [[1,&#x27;one&#x27;], [2, &#x27;two&#x27;], [3, &#x27;three&#x27;]]</span></span><br><span class="line"><span class="built_in">console</span>.log([...map]); <span class="comment">// [[1,&#x27;one&#x27;], [2, &#x27;two&#x27;], [3, &#x27;three&#x27;]]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Map结合数组的filter实现遍历</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map0 = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">  .set(<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">  .set(<span class="number">2</span>, <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">  .set(<span class="number">3</span>, <span class="string">&#x27;c&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> map1 = <span class="keyword">new</span> <span class="built_in">Map</span>(</span><br><span class="line">  [...map0].filter(<span class="function">(<span class="params">[k, v]</span>) =&gt;</span> &#123; <span class="keyword">return</span> k &lt; <span class="number">3</span>;&#125;)</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 产生 Map 结构 &#123;1 =&gt; &#x27;a&#x27;, 2 =&gt; &#x27;b&#x27;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(map1);</span><br></pre></td></tr></table></figure>

<h3 id="4-4-3-Map数据结构与其它数据结构的转换"><a href="#4-4-3-Map数据结构与其它数据结构的转换" class="headerlink" title="4.4.3 Map数据结构与其它数据结构的转换"></a>4.4.3 Map数据结构与其它数据结构的转换</h3><ol>
<li><p>Map转数组，使用扩展运算符(…)</p>
</li>
<li><p>数组转map，使用map构造函数</p>
</li>
<li><p>Map转为对象</p>
</li>
<li><p>对象转为 Map 可以通过<code>Object.entries()</code></p>
</li>
<li><p>Map转JSON(1. map的键为字符串的情况,转为对象JSON 2.map中的键含有非字符串,转为数组JSON)</p>
</li>
<li><p>JSON转map</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map0 = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">  .set(<span class="string">&#x27;person&#x27;</span>,<span class="string">&#x27;张三&#x27;</span>)</span><br><span class="line">  .set(<span class="string">&#x27;stock&#x27;</span>,<span class="string">&#x27;股票&#x27;</span>)</span><br><span class="line">  .set(<span class="string">&#x27;company&#x27;</span>,<span class="string">&#x27;恒瑞医药&#x27;</span>)</span><br><span class="line">  .set(<span class="string">&#x27;fund&#x27;</span>,<span class="string">&#x27;中概互联网&#x27;</span>);</span><br><span class="line"><span class="comment">// map 转数组</span></span><br><span class="line"><span class="built_in">console</span>.log([...map0]); </span><br><span class="line"><span class="keyword">let</span> arr = [[<span class="string">&#x27;person&#x27;</span>,<span class="string">&#x27;张三&#x27;</span>],[<span class="string">&#x27;age&#x27;</span>,<span class="number">18</span>],[<span class="string">&#x27;country&#x27;</span>,<span class="string">&#x27;中国&#x27;</span>]];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组转map</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Map</span>(arr)); </span><br><span class="line"></span><br><span class="line"><span class="comment">// map 转对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeObj</span>(<span class="params">map0</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> changeObject = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> map0.entries())&#123;</span><br><span class="line">    changeObject[item[<span class="number">0</span>]] = item[<span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> changeObject;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj1 = changeObj(map0);</span><br><span class="line"><span class="built_in">console</span>.log(obj1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象转map</span></span><br><span class="line"><span class="keyword">let</span> newObj = &#123;</span><br><span class="line">  <span class="attr">person</span>:<span class="string">&#x27;刘恒&#x27;</span>,</span><br><span class="line">  <span class="attr">name</span>:<span class="string">&#x27;汉文帝&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>:<span class="number">99</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Map</span>(<span class="built_in">Object</span>.entries(newObj)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Map转JSON(map的键为字符串的情况,转为对象JSON)</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(changeObj(map0)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Map转JSON(map中的键含有非字符串,转为数组JSON)</span></span><br><span class="line"><span class="keyword">let</span> map1 = map0;</span><br><span class="line">map1.set(<span class="number">1</span>,<span class="string">&#x27;转为数组JSON&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify([...map1]));</span><br><span class="line"></span><br><span class="line"><span class="comment">// JSON转map</span></span><br><span class="line"><span class="comment">// let jsonMap = JSON.stringify(changeObj(map0));</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonToStrMap</span>(<span class="params">jsonStr</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// JSON.parse 将字符串转为对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Map</span>(<span class="built_in">Object</span>.entries(<span class="built_in">JSON</span>.parse(jsonStr)))</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(jsonToStrMap(<span class="string">&#x27;&#123;&quot;yes&quot;: true, &quot;no&quot;: false&#125;&#x27;</span>));</span><br></pre></td></tr></table></figure>

<h2 id="4-5-weakMap数据结构"><a href="#4-5-weakMap数据结构" class="headerlink" title="4.5 weakMap数据结构"></a>4.5 weakMap数据结构</h2><ul>
<li><code>WeakMap</code>结构与<code>Map</code>结构类似，也是用于生成键值对的集合，但是weakMap只接受对象类型的键值对，如果将数值<code>1</code>和<code>Symbol</code>值作为 WeakMap 的键名，都会报错；</li>
</ul>
<p>其次，<code>WeakMap</code>的键名所指向的对象，不计入垃圾回收机制。</p>
<p><code>WeakMap</code>的设计目的在于，有时我们想在某个对象上面存放一些数据，但是这会形成对于这个对象的引用。请看下面的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> e1 = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> e2 = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> arr = [</span><br><span class="line">  [e1, <span class="string">&#x27;foo 元素&#x27;</span>],</span><br><span class="line">  [e2, <span class="string">&#x27;bar 元素&#x27;</span>],</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>e1</code>和<code>e2</code>是两个对象，我们通过<code>arr</code>数组对这两个对象添加一些文字说明。这就形成了<code>arr</code>对<code>e1</code>和<code>e2</code>的引用。</p>
<p>一旦不再需要这两个对象，我们就必须手动删除这个引用，否则垃圾回收机制就不会释放<code>e1</code>和<code>e2</code>占用的内存。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不需要 e1 和 e2 的时候</span></span><br><span class="line"><span class="comment">// 必须手动删除引用</span></span><br><span class="line">arr [<span class="number">0</span>] = <span class="literal">null</span>;</span><br><span class="line">arr [<span class="number">1</span>] = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p>上面这样的写法显然很不方便。一旦忘了写，就会造成内存泄露。</p>
<p>WeakMap 就是为了解决这个问题而诞生的，它的键名所引用的对象都是弱引用，即垃圾回收机制不将该引用考虑在内。因此，只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。也就是说，一旦不再需要，WeakMap 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用。</p>
<p>基本上，如果你要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用 WeakMap。一个典型应用场景是，在网页的 DOM 元素上添加数据，就可以使用<code>WeakMap</code>结构。当该 DOM 元素被清除，其所对应的<code>WeakMap</code>记录就会自动被移除。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> element = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;example&#x27;</span>);</span><br><span class="line"></span><br><span class="line">wm.set(element, <span class="string">&#x27;some information&#x27;</span>);</span><br><span class="line">wm.get(element) <span class="comment">// &quot;some information&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，先新建一个 WeakMap 实例。然后，将一个 DOM 节点作为键名存入该实例，并将一些附加信息作为键值，一起存放在 WeakMap 里面。这时，WeakMap 里面对<code>element</code>的引用就是弱引用，不会被计入垃圾回收机制。</p>
<ul>
<li>总之，<code>WeakMap</code>的专用场合就是，它的键所对应的对象，可能会在将来消失。<code>WeakMap</code>结构有助于防止内存泄漏。</li>
</ul>
<h3 id="4-5-1-weakMap语法"><a href="#4-5-1-weakMap语法" class="headerlink" title="4.5.1 weakMap语法"></a>4.5.1 weakMap语法</h3><ol>
<li>与weakMap与Map的API主要差别在于，一是没有遍历操作（即没有<code>keys()</code>、<code>values()</code>和<code>entries()</code>方法），也没有<code>size</code>属性。</li>
<li>无法清空，即是没有clear()方法；</li>
<li>weakMap只有4个方法可以用，即是get(),set(),has(),delete();</li>
</ol>
<p>注意：<strong>WeakMap 弱引用的只是键名，而不是键值。键值依然是正常引用</strong>;</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="keyword">let</span> person = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;张三&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> key = &#123;&#125;;</span><br><span class="line">wm.set(key,person);</span><br><span class="line"><span class="built_in">console</span>.log(wm);</span><br><span class="line">person = <span class="literal">null</span>; <span class="comment">// 此处体现了引用的只是键名，键值正常引用</span></span><br><span class="line"><span class="built_in">console</span>.log(wm.get(key));</span><br></pre></td></tr></table></figure>

<h2 id="4-6-weakRef数据结构，用于直接创建对象的弱引用"><a href="#4-6-weakRef数据结构，用于直接创建对象的弱引用" class="headerlink" title="4.6 weakRef数据结构，用于直接创建对象的弱引用"></a>4.6 weakRef数据结构，用于直接创建对象的弱引用</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> wr = <span class="keyword">new</span> WeakRef(target);</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>target</code>是原始对象，构造函数<code>WeakRef()</code>创建了一个基于<code>target</code>的新对象<code>wr</code>。这里，<code>wr</code>就是一个 WeakRef 的实例，属于对<code>target</code>的弱引用，垃圾回收机制不会计入这个引用，也就是说，<code>wr</code>的引用不会妨碍原始对象<code>target</code>被垃圾回收机制清除。</p>
<p>WeakRef 实例对象有一个<code>deref()</code>方法，如果原始对象存在，该方法返回原始对象；如果原始对象已经被垃圾回收机制清除，该方法返回<code>undefined</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> wr = <span class="keyword">new</span> WeakRef(target);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = wr.deref();</span><br><span class="line"><span class="keyword">if</span> (obj) &#123; <span class="comment">// target 未被垃圾回收机制清除</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>deref()</code>方法可以判断原始对象是否已被清除。</p>
<h1 id="5-Proxy-代理"><a href="#5-Proxy-代理" class="headerlink" title="5. Proxy(代理)"></a>5. Proxy(代理)</h1><p>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”；</p>
<ul>
<li>实例的生成，ES6原生提供Proxy构造函数，用来生成Proxy实例；</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target,handler);</span><br></pre></td></tr></table></figure>

<p>Proxy对象当所有用法，都是上面的形式，不同的只是handler参数的写法，其中，new Proxy()表示生成一个Proxy实例，target参数表示所要拦截的目标对象，handler参数也是一个对象，用来定义拦截行为；</p>
<h2 id="5-1-Proxy实例方法的使用"><a href="#5-1-Proxy实例方法的使用" class="headerlink" title="5.1 Proxy实例方法的使用"></a>5.1 Proxy实例方法的使用</h2><h3 id="5-1-1get-方法"><a href="#5-1-1get-方法" class="headerlink" title="5.1.1get()方法"></a>5.1.1get()方法</h3><ol>
<li><code>get</code>方法用于拦截某个属性的读取操作，可以接受三个参数，依次为目标对象、属性名和 proxy 实例本身（严格地说，是操作行为所针对的对象），其中最后一个参数可选</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>:<span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">  <span class="attr">country</span>: <span class="string">&#x27;中国&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(person,&#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params">target,propKey</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(propKey <span class="keyword">in</span> target)&#123;</span><br><span class="line">    	<span class="keyword">return</span> target[propKey];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">ReferenceError</span>(<span class="string">&quot;Prop name &quot;</span>+propKey +<span class="string">&quot; does not exist!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(proxy.name);  <span class="comment">// 张三</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.tall); <span class="comment">// ReferenceError: Prop name tall does not exist!</span></span><br></pre></td></tr></table></figure>

<p>上面代码表示，如果访问目标对象不存在的属性，会抛出一个错误。如果没有这个拦截函数，访问不存在的属性，只会返回<code>undefined</code>；</p>
<p>注意：get()方法可以继承</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对读取的拦截</span></span><br><span class="line"><span class="keyword">let</span> proto = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;,&#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">target,propKey,receiver</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;GET&#x27;</span>,propKey,target);</span><br><span class="line">    <span class="keyword">return</span> target[propKey];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> obj = <span class="built_in">Object</span>.create(proto);</span><br><span class="line">obj.foo; <span class="comment">// 此处是读取操作，因此会被拦截，如果是写操作如：(obj.foo=&quot;张三&quot;),则不会被get拦截</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，拦截操作定义在<code>Prototype</code>对象上面，所以如果读取<code>obj</code>对象继承的属性时，拦截会生效。</p>
<p>下面的例子使用<code>get</code>拦截，实现数组读取负数的索引(待补充）：</p>
<h3 id="5-1-2-set-方法"><a href="#5-1-2-set-方法" class="headerlink" title="5.1.2 set()方法"></a>5.1.2 set()方法</h3><p>set方法用来拦截某个属性的赋值操作，可以接收4个参数，依次为目标对象、属性名、属性值和Proxy实例本身，最后一个参数可选；</p>
<p><strong>举例：</strong> 假定<code>Person</code>对象有一个<code>age</code>属性，该属性应该是一个不大于 200 的整数，那么可以使用<code>Proxy</code>保证<code>age</code>的属性值符合要求；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对赋值的拦截</span></span><br><span class="line"><span class="keyword">let</span> handler = &#123;</span><br><span class="line">  <span class="function"><span class="title">set</span>(<span class="params">obj,name,value</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(name = <span class="string">&#x27;age&#x27;</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span>(value&gt;=<span class="number">200</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">ReferenceError</span>(<span class="string">&quot;error,您所设置的值过大！！！&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(!<span class="built_in">Number</span>.isInteger(value))&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;The age is not an integer!!!&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  	&#125;</span><br><span class="line">    <span class="comment">// 满足条件则直接保存</span></span><br><span class="line">    obj[name]=value;</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;,handler);</span><br><span class="line">person.age = <span class="number">100</span>;</span><br><span class="line">person.age = <span class="number">1000</span>; <span class="comment">// error,您所设置的值过大！！！</span></span><br><span class="line">person.age = <span class="string">&#x27;stupid&#x27;</span>; <span class="comment">// The age is not an integer!!!</span></span><br></pre></td></tr></table></figure>



<ul>
<li>set和get方法的结合，实现私有变量不让修改；</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// get 结合 set</span></span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">target,key</span>)</span>&#123;</span><br><span class="line">    isFlag(key,<span class="string">&#x27;get&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> target[key];</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">set</span>(<span class="params">target,key,value</span>)</span>&#123;</span><br><span class="line">    isFlag(key,<span class="string">&#x27;set&#x27;</span>);</span><br><span class="line">    target[key] = value;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isFlag</span>(<span class="params">key,action</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(key[<span class="number">0</span>]===<span class="string">&#x27;_&#x27;</span>)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`Invalid attempt to <span class="subst">$&#123;action&#125;</span> private &quot;<span class="subst">$&#123;key&#125;</span>&quot; property`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> target = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target,handler);</span><br><span class="line">proxy._prop;</span><br><span class="line">proxy._prop = <span class="string">&#x27;set&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="5-1-2-apply-方法"><a href="#5-1-2-apply-方法" class="headerlink" title="5.1.2 apply()方法"></a>5.1.2 apply()方法</h3><ul>
<li><p>含义</p>
<p>apply方法拦截函数的调用，call和apply操作</p>
<p>apply方法可以接收三个参数，分别是目标对象、目标对象当上下文对象（this）和目标对象当参数数组；</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// apply()方法</span></span><br><span class="line"><span class="keyword">let</span> twice = &#123;</span><br><span class="line">  <span class="function"><span class="title">apply</span>(<span class="params">target, ctx, args</span>)</span>&#123;</span><br><span class="line">  	<span class="built_in">console</span>.log(args);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.apply(...arguments)*<span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">left,right</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> left + right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(sum,twice);</span><br><span class="line"><span class="built_in">console</span>.log(proxy(<span class="number">1</span>,<span class="number">3</span>));</span><br><span class="line">proxy.call(<span class="literal">null</span>, <span class="number">5</span>, <span class="number">6</span>) <span class="comment">// 22</span></span><br><span class="line">proxy.apply(<span class="literal">null</span>, [<span class="number">7</span>, <span class="number">8</span>]) <span class="comment">// 30</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，每当执行<code>proxy</code>函数（直接调用或<code>call</code>和<code>apply</code>调用），就会被<code>apply</code>方法拦截；</p>
<h3 id="5-1-4-has-方法"><a href="#5-1-4-has-方法" class="headerlink" title="5.1.4 has()方法"></a>5.1.4 has()方法</h3><p><code>has()</code>方法用来拦截<code>HasProperty</code>操作，即判断对象是否具有某个属性时，这个方法会生效。典型的操作就是<code>in</code>运算符。</p>
<p><code>has()</code>方法可以接受两个参数，分别是目标对象、需查询的属性名。</p>
<p>下面的例子使用<code>has()</code>方法隐藏某些属性，不被<code>in</code>运算符发现。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;</span><br><span class="line">  <span class="attr">_foo</span>: <span class="string">&#x27;_prop&#x27;</span>,</span><br><span class="line">  <span class="attr">person</span>:<span class="string">&#x27;张三&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> handler = &#123;</span><br><span class="line">  <span class="function"><span class="title">has</span>(<span class="params">target,key</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(key[<span class="number">0</span>]===<span class="string">&#x27;_&#x27;</span>)&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;该属性不存在&#x27;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> key <span class="keyword">in</span> target;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target,handler);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;_foo&#x27;</span> <span class="keyword">in</span> proxy); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;person&#x27;</span> <span class="keyword">in</span> proxy); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>值得注意的是，<code>has()</code>方法拦截的是<code>HasProperty</code>操作，而不是<code>HasOwnProperty</code>操作，即<code>has()</code>方法不判断一个属性是对象自身的属性，还是继承的属性;</p>
<h1 id="6-Reflect结构"><a href="#6-Reflect结构" class="headerlink" title="6.Reflect结构"></a>6.Reflect结构</h1><h1 id="12-类的基本语法"><a href="#12-类的基本语法" class="headerlink" title="12. 类的基本语法"></a>12. 类的基本语法</h1><p>类与ES5中的构造函数类似，ES6中的类可以看做是构造函数的另一种写法，类的数据类型就是函数，类本身就指向构造函数。使用的时候，也是直接对类使用<code>new</code>命令，跟构造函数的用法完全一致。构造函数的<code>prototype</code>属性，在 ES6 的“类”上面继续存在。事实上，类的所有方法都定义在类的<code>prototype</code>属性上面；</p>
<p>下面的Person类可以体现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">say</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;I am &#x27;</span>+<span class="built_in">this</span>.name+ <span class="string">&#x27; and I was &#x27;</span> +<span class="built_in">this</span>.age +<span class="string">&#x27; year ago!&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面的say()方法定义等同于</span></span><br><span class="line"><span class="comment">/* Person.prototype.say = function()&#123;</span></span><br><span class="line"><span class="comment">      console.log(&#x27;我是一个人类！&#x27;);</span></span><br><span class="line"><span class="comment">    &#125; */</span></span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person(<span class="string">&#x27;Tom&#x27;</span>,<span class="number">18</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> Person); <span class="comment">// function</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.constructor === Person); <span class="comment">// true</span></span><br><span class="line">person1.say();</span><br></pre></td></tr></table></figure>

<ul>
<li>由于类的方法都定义在<code>prototype</code>对象上面，所以类的新方法可以添加在<code>prototype</code>对象上面。<code>Object.assign()</code>方法可以很方便地一次向类添加多个方法。</li>
</ul>
<p>接Person类，将两个方法添加到Persona类中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(Person.prototype,&#123;</span><br><span class="line">  <span class="function"><span class="title">sayHello</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  	<span class="built_in">console</span>.log(<span class="string">&#x27;Hello Javascript Person class!&#x27;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">returnNumber</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  	<span class="built_in">console</span>.log(<span class="number">99999999</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">person1.sayHello(); <span class="comment">//Hello Javascript Person class!</span></span><br></pre></td></tr></table></figure>

<h2 id="1-constructor方法"><a href="#1-constructor方法" class="headerlink" title="1. constructor方法"></a>1. constructor方法</h2><p><code>constructor()</code>方法是类的默认方法，也叫构造方法，通过<code>new</code>命令生成对象实例时，自动调用该方法。一个类必须有<code>constructor()</code>方法，如果没有显式定义，一个空的<code>constructor()</code>方法会被默认添加</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类必须使用<code>new</code>调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用<code>new</code>也可以执行</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo()</span><br><span class="line"><span class="comment">// TypeError: Class constructor Foo cannot be invoked without &#x27;new&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-类的实例"><a href="#2-类的实例" class="headerlink" title="2. 类的实例"></a>2. 类的实例</h2><ul>
<li><p>生成类的实例的写法，与 ES5 完全一样，也是使用<code>new</code>命令。前面说过，如果忘记加上<code>new</code>，像函数那样调用<code>Class</code>，将会报错</p>
</li>
<li><p>与 ES5 一样，实例的属性除非显式定义在其本身（即定义在<code>this</code>对象上），否则都是定义在原型上（即定义在<code>class</code>上），类的所有实例共享一个原型对象，这也意味着，可以通过实例的<code>__proto__</code>属性为“类”添加方法（但不推荐使用）。；</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="comment">// 显式定义方法</span></span><br><span class="line">    <span class="built_in">this</span>.run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;I will run!&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 非显式定义方法</span></span><br><span class="line">  <span class="function"><span class="title">say</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;I am &#x27;</span>+<span class="built_in">this</span>.name+ <span class="string">&#x27; and I was &#x27;</span> +<span class="built_in">this</span>.age +<span class="string">&#x27; year ago!&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person(<span class="string">&#x27;Tom&#x27;</span>,<span class="number">18</span>);</span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> Person(<span class="string">&#x27;Jacket&#x27;</span>,<span class="number">20</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person1.__proto__ === person2.__proto__); <span class="comment">// true 可见person1和person2共享一个原型对象</span></span><br><span class="line"><span class="comment">// 通过__proto__添加方法,一个实例定义所有实例都可以使用</span></span><br><span class="line">person1.__proto__.fly = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;I will fly!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">person2.fly(); <span class="comment">// I will fly!</span></span><br><span class="line">person1.fly(); <span class="comment">// I will fly!</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.hasOwnProperty(<span class="string">&#x27;age&#x27;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.hasOwnProperty(<span class="string">&#x27;say&#x27;</span>)); <span class="comment">// false 非显式定义，因此不是本身含有的属性</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.hasOwnProperty(<span class="string">&#x27;run&#x27;</span>)); <span class="comment">// true </span></span><br></pre></td></tr></table></figure>

<h2 id="3-类的取值函数-getter-和存值函数-setter"><a href="#3-类的取值函数-getter-和存值函数-setter" class="headerlink" title="3. 类的取值函数(getter)和存值函数(setter)"></a>3. 类的取值函数(getter)和存值函数(setter)</h2><p>在类的内部可以使用get和set关键字，对某个属性设置存值函数和取值函数拦截该属性的存取行为；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">element</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.element = element;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">prop</span>()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;getter&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title">prop</span>(<span class="params">value</span>)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setter存的数是：&#x27;</span>+value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(</span><br><span class="line">  MyClass.prototype,<span class="string">&quot;prop&quot;</span></span><br><span class="line">);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;get&quot;</span> <span class="keyword">in</span> descriptor); <span class="comment">// true</span></span><br><span class="line"><span class="keyword">let</span> meClass = <span class="keyword">new</span> MyClass();</span><br><span class="line">meClass.prop = <span class="number">123</span>;</span><br><span class="line"><span class="built_in">console</span>.log(meClass.prop);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>prop</code>属性有对应的存值函数和取值函数，因此赋值和读取行为都被自定义了，上面代码中，存值函数和取值函数是定义在<code>html</code>属性的描述对象上面，这与 ES5 完全一致。</p>
<h2 id="4-Class表达式"><a href="#4-Class表达式" class="headerlink" title="4. Class表达式"></a>4. Class表达式</h2><p>与函数一样，类也可以使用表达式的形式定义。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyClass = <span class="class"><span class="keyword">class</span> <span class="title">Me</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">getClassName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Me.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码使用表达式定义了一个类。需要注意的是，这个类的名字是<code>Me</code>，但是<code>Me</code>只在 Class 的内部可用，指代当前类。在 Class 外部，这个类只能用<code>MyClass</code>引用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> inst = <span class="keyword">new</span> MyClass();</span><br><span class="line">inst.getClassName() <span class="comment">// Me</span></span><br><span class="line">Me.name <span class="comment">// ReferenceError: Me is not defined</span></span><br></pre></td></tr></table></figure>

<p>上面代码表示，<code>Me</code>只在 Class 内部有定义。</p>
<p>如果类的内部没用到的话，可以省略<code>Me</code>，也就是可以写成下面的形式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyClass = <span class="class"><span class="keyword">class</span> </span>&#123; <span class="comment">/* ... */</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>采用 Class 表达式，可以写出立即执行的 Class。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">sayName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;(<span class="string">&#x27;张三&#x27;</span>);</span><br><span class="line"></span><br><span class="line">person.sayName(); <span class="comment">// &quot;张三&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>person</code>是一个立即执行的类的实例。</p>
<h2 id="5-注意点"><a href="#5-注意点" class="headerlink" title="5. 注意点"></a>5. 注意点</h2><ol>
<li>class自定义开始就是使用严格模式</li>
<li>不存在提升，必须要先定义类才能够使用类，顺序不能够颠倒</li>
<li>name属性</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(Animal.name);</span><br></pre></td></tr></table></figure>

<h3 id="this指向问题"><a href="#this指向问题" class="headerlink" title="this指向问题"></a>this指向问题</h3><p>类的方法内部如果含有<code>this</code>，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// this指向问题</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">sayLog</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.sayHello();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">sayHello</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Hello World!&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> logger = <span class="keyword">new</span> Logger();</span><br><span class="line"><span class="keyword">let</span> &#123; sayLog &#125; = logger; </span><br><span class="line"><span class="comment">//TypeError: Cannot read properties of undefined (reading &#x27;sayHello&#x27;)</span></span><br><span class="line">sayLog();</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>sayLog</code>方法中的<code>this</code>，默认指向<code>Logger</code>类的实例。但是，如果将这个方法提取出来单独使用，<code>this</code>会指向该方法运行时所在的环境（由于 class 内部是严格模式，所以 this 实际指向的是<code>undefined</code>），从而导致找不到<code>sayHello</code>方法而报错。</p>
<p>一个比较简单的解决方法是，在构造方法中绑定<code>this</code>，这样就不会找不到<code>print</code>方法了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="built_in">this</span>.sayLog = <span class="built_in">this</span>.sayLog.bind(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">sayLog</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.sayHello();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">sayHello</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Hello World!&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> logger = <span class="keyword">new</span> Logger();</span><br><span class="line"><span class="keyword">let</span> &#123; sayLog &#125; = logger; </span><br><span class="line">sayLog();</span><br></pre></td></tr></table></figure>

<p>另一种解决方法是使用箭头函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  sayLog=<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.sayHello();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">sayHello</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Hello World!&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> logger = <span class="keyword">new</span> Logger();</span><br><span class="line"><span class="keyword">let</span> &#123; sayLog &#125; = logger; </span><br><span class="line">sayLog();</span><br></pre></td></tr></table></figure>

<p><strong>箭头函数内部的<code>this</code>总是指向定义时所在的对象</strong>。上面代码中，箭头函数位于构造函数内部，它的定义生效的时候，是在构造函数执行的时候。这时，箭头函数所在的运行环境，肯定是实例对象，所以<code>this</code>会总是指向实例对象。</p>
<h2 id="6-类的静态方法"><a href="#6-类的静态方法" class="headerlink" title="6. 类的静态方法"></a>6. 类的静态方法</h2><p>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前加上static关键字，就表示该方法不会被实例继承，而是直接通过类自身来调用，这就成为静态方法；静态方法可以与非静态方法重名。</p>
<p>类自身来调用静态方法，如果在实例上调用静态方法，会抛出一个错误，表示不存在该方法：    </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span></span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">sayHello</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> 	  <span class="built_in">console</span>.log(<span class="string">&#x27;Hello World!&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> log1 = <span class="keyword">new</span> Logger();</span><br><span class="line"><span class="comment">// log1.sayHello(); // TypeError: log1.sayHello is not a function</span></span><br><span class="line">Logger.sayHello();  <span class="comment">// Hello World!</span></span><br></pre></td></tr></table></figure>

<p>父类的静态方法，可以被子类继承：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">sayHello</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  	<span class="built_in">console</span>.log(<span class="string">&#x27;Hello World!&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Son.sayHello(); <span class="comment">//  Hello World!</span></span><br></pre></td></tr></table></figure>



<h1 id="13-类的继承"><a href="#13-类的继承" class="headerlink" title="13. 类的继承"></a>13. 类的继承</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p>Class 可以通过<code>extends</code>关键字实现继承父类的所有属性和方法(包括静态方法)；</p>
<p><strong>子类必须在<code>constructor</code>方法中调用<code>super</code>方法</strong>，否则新建实例时会报错。这是因为子类自己的<code>this</code>对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用<code>super</code>方法，子类就得不到<code>this</code>对象；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name,typeClimate</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.typeClimate = typeClimate;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">returnClimate</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  	<span class="built_in">console</span>.log(<span class="built_in">this</span>.name+<span class="string">&quot; belong &quot;</span>+<span class="built_in">this</span>.typeClimate);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pig</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name,typeClimate,food</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 如果没有super()方法，会在创建类实例的时候报错</span></span><br><span class="line">  <span class="comment">// ReferenceError: Must call super constructor in derived class before </span></span><br><span class="line">  <span class="comment">// accessing &#x27;this&#x27; or returning from derived constructor at new Pig</span></span><br><span class="line">  	<span class="built_in">super</span>(name,typeClimate);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pig1 = <span class="keyword">new</span> Pig(<span class="string">&#x27;小猪佩奇&#x27;</span>,<span class="string">&#x27;pig&#x27;</span>,<span class="string">&#x27;rice&#x27;</span>);</span><br><span class="line">pig1.returnClimate();</span><br></pre></td></tr></table></figure>



<h2 id="2-Object-getPrototypeOf"><a href="#2-Object-getPrototypeOf" class="headerlink" title="2. Object.getPrototypeOf()"></a>2. Object.getPrototypeOf()</h2><p><code>Object.getPrototypeOf</code>方法可以用来从子类上获取父类;</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(Pig) === Animal); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>



<h2 id="3-super关键字"><a href="#3-super关键字" class="headerlink" title="3. super关键字"></a>3. super关键字</h2><p><code>super</code>这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同；ES6 要求，子类的构造函数必须执行一次<code>super</code>函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中，子类B的构造函数中的super()，代表调用父类的构造函数、这是必须的，否则会报错；</p>
<p>注意，<code>super</code>虽然代表了父类<code>A</code>的构造函数，但是返回的是子类<code>B</code>的实例，即<code>super</code>内部的<code>this</code>指的是<code>B</code>的实例，因此<code>super()</code>在这里相当于<code>A.prototype.constructor.call(this)</code>，作为函数时，<code>super()</code>只能用在子类的构造函数之中，用在其他地方就会报错。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  	<span class="built_in">console</span>.log(<span class="keyword">new</span>.target.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  	<span class="built_in">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> A()); <span class="comment">// A</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> B()); <span class="comment">// B</span></span><br></pre></td></tr></table></figure>

<p>上面的代码中，new.target指向当前正在执行的函数，可以看到，在super()执行的时候，指向的是子类B的构造函数，而不是父类A的构造函数，即super()内部的this指向的是B；</p>
<ul>
<li>第二种情况，<code>super</code>作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">p</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;super 调用&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">super</span>.p());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> B(); <span class="comment">// super 调用</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，子类当中的super.p()，就是将super当作一个对象来使用。这时，super在普通方法之中，指向A.prototype，因此super.p()相当于A.prototype.p();</p>
<p>这里需要注意，由于<code>super</code>指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过<code>super</code>调用的，但是定义在父类的原型对象上，则可以通过super进行访问:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.x = <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">A.prototype.y = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">say</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">super</span>.x);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">super</span>.y);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> bClass = <span class="keyword">new</span> B();</span><br><span class="line">bClass.say();  <span class="comment">// x为undefined 获取失败 y为5 获取成功</span></span><br></pre></td></tr></table></figure>

<p>ES6 规定，在子类普通方法中通过<code>super</code>调用父类的方法时，方法内部的<code>this</code>指向当前的子类实例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.outPut = <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">print</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.outPut); <span class="comment">// 这里的this指向的是子类的实例对象</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="built_in">this</span>.outPut = <span class="number">99</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">say</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">super</span>.print();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> bClass = <span class="keyword">new</span> B();</span><br><span class="line">bClass.say();  <span class="comment">// 99</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，super.print()虽然调用的是A.prototype.print()，但是由于A.prototype.print()内部的this指向的是子类B实例，因此导致输出是99，而不是2也就是说明实际上执行的是super.print.call(this);</p>
<ul>
<li>由于<code>this</code>指向子类实例，所以如果通过<code>super</code>对某个属性赋值，这时<code>super</code>就是<code>this</code>，赋值的属性会变成子类实例的属性:</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  	<span class="built_in">this</span>.outPut = <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">print</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  	<span class="built_in">console</span>.log(<span class="built_in">this</span>.outPut); <span class="comment">// 这里的this指向的是子类的实例对象</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  	<span class="built_in">super</span>();</span><br><span class="line">  	<span class="built_in">super</span>.outPut = <span class="number">33</span>;</span><br><span class="line">  	<span class="built_in">this</span>.outPut = <span class="number">11</span>;</span><br><span class="line">  	<span class="built_in">console</span>.log(<span class="built_in">super</span>.outPut); <span class="comment">// undefined </span></span><br><span class="line">  	<span class="built_in">console</span>.log(<span class="built_in">this</span>.outPut); <span class="comment">// 11 outPut被super.outPut改变了</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> bClass = <span class="keyword">new</span> B();</span><br></pre></td></tr></table></figure>

<p>上面代码，super.outPut = 11，将outPut赋值为11，在输出super.outPut时，super指向父类A的原型对象prototype，由于super无法访问父类上的属性和方法，因此会报错undefined，在输出this.outPut中的this指向B类的实例 因此输出11；</p>
<ul>
<li>如果<code>super</code>作为对象，用在静态方法之中，这时<code>super</code>将指向父类，而不是父类的原型对象</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">method</span>(<span class="params">message</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(message+<span class="string">&#x27;static method&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">myMethod</span>(<span class="params">message</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(message+<span class="string">&#x27;ordinary method&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">method</span>(<span class="params">message</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">super</span>.method(message);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">myMethod</span>(<span class="params">message</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">super</span>.myMethod(message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.method(<span class="string">&#x27;super的测试！&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> child1 = <span class="keyword">new</span> Child();</span><br><span class="line">child1.myMethod(<span class="string">&#x27;what do you say?&#x27;</span>);</span><br><span class="line"><span class="comment">// 因为子类的实例通过super访问父类的静态方法</span></span><br><span class="line"><span class="comment">// this指向的是子类，而子类中没有method方法，因此报错</span></span><br><span class="line">child1.method(<span class="string">&#x27;can I say?&#x27;</span>); <span class="comment">// TypeError: child1.method is not a function</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>super</code>在静态方法之中指向父类，在普通方法之中指向父类的原型对象。</p>
<p>注意，使用<code>super</code>的时候，必须显式指定是作为函数、还是作为对象使用，<strong>否则会报错</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="comment">// console.log(super);//报错</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>console.log(super)</code>当中的<code>super</code>，无法看出是作为函数使用，还是作为对象使用，所以 JavaScript 引擎解析代码的时候就会报错。这时，如果能清晰地表明<code>super</code>的数据类型，就不会报错；</p>
<h2 id="4-类的prototype和-proto-属性"><a href="#4-类的prototype和-proto-属性" class="headerlink" title="4. 类的prototype和__proto__属性"></a>4. 类的prototype和<code>__proto__</code>属性</h2><p>大多数浏览器的 ES5 实现之中，每一个对象都有<code>__proto__</code>属性，指向对应的构造函数的<code>prototype</code>属性。Class 作为构造函数的语法糖，同时有<code>prototype</code>属性和<code>__proto__</code>属性，因此同时存在两条继承链；</p>
<ol>
<li>子类的<code>__proto__</code>属性，表示构造函数的继承，总是指向父类；</li>
<li>子类prototype属性的<code>__proto__</code>属性，表示方法的继承，总是指向父类的prototype属性；</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  	<span class="built_in">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(B.__proto__ === A); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(B.prototype.__proto__ === A.prototype); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>子类B的<code>__proto__</code>属性指向了父类A，子类B的原型对象上的<code>__proto__</code>属性指向了父类A的原型原型对象prototype</p>
<h2 id="5-extends关键字后面可以跟多种类型的值"><a href="#5-extends关键字后面可以跟多种类型的值" class="headerlink" title="5. extends关键字后面可以跟多种类型的值"></a>5. <code>extends</code>关键字后面可以跟多种类型的值</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码的<code>A</code>，只要是一个有<code>prototype</code>属性的函数，就能被<code>B</code>继承。由于函数都有<code>prototype</code>属性（除了<code>Function.prototype</code>函数），因此<code>A</code>可以是任意函数。</p>
<ol>
<li>子类继承Object类</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子类继承Object类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">Object</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(A.__proto__ === <span class="built_in">Object</span>); <span class="comment">// ture </span></span><br><span class="line"><span class="built_in">console</span>.log(A.prototype.__proto__ === <span class="built_in">Object</span>.prototype);</span><br></pre></td></tr></table></figure>

<p>这种情况下，<code>A</code>其实就是构造函数<code>Object</code>的复制，<code>A</code>的实例就是<code>Object</code>的实例</p>
<ol start="2">
<li>不存在任何继承</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(A.__proto__ === <span class="built_in">Function</span>.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(A.prototype.__proto__ === <span class="built_in">Object</span>.prototype); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>这种情况下，<code>A</code>作为一个基类（即不存在任何继承），就是一个普通函数，所以直接继承<code>Function.prototype</code>。但是，<code>A</code>调用后返回一个空对象（即<code>Object</code>实例），所以<code>A.prototype.__proto__</code>指向构造函数（<code>Object</code>）的<code>prototype</code>属性；</p>
<h2 id="6-实例的-proto"><a href="#6-实例的-proto" class="headerlink" title="6. 实例的__proto__"></a>6. 实例的<code>__proto__</code></h2><p>子类实例的<code>__proto__</code>属性的<code>__proto__</code>属性，指向父类实例的<code>__proto__</code>属性。也就是说，子类的原型的原型，是父类的原型</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> classA = <span class="keyword">new</span> A();</span><br><span class="line"><span class="keyword">let</span> classB = <span class="keyword">new</span> B();</span><br><span class="line"><span class="comment">// 改变了父类的行为，看classA.printName()方法可知</span></span><br><span class="line">classB.__proto__.__proto__.printName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&#x27;Hello World!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(classA.__proto__ === classB.__proto__); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(classA.__proto__ === classB.__proto__.__proto__); <span class="comment">// true</span></span><br><span class="line">classA.printName();</span><br></pre></td></tr></table></figure>

<p>因此，通过子类实例的<code>__proto__.__proto__</code>属性，可以修改父类实例的行为;</p>
<h2 id="7-原生构造函数的继承"><a href="#7-原生构造函数的继承" class="headerlink" title="7. 原生构造函数的继承"></a>7. 原生构造函数的继承</h2><p>原生的构造函数有如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Boolean</span>()</span><br><span class="line"><span class="built_in">Number</span>()</span><br><span class="line"><span class="built_in">String</span>()</span><br><span class="line"><span class="built_in">Array</span>()</span><br><span class="line"><span class="built_in">Date</span>()</span><br><span class="line"><span class="built_in">Function</span>()</span><br><span class="line"><span class="built_in">RegExp</span>()</span><br><span class="line"><span class="built_in">Error</span>()</span><br><span class="line"><span class="built_in">Object</span>()</span><br></pre></td></tr></table></figure>

<p>ES6 允许继承原生构造函数定义子类，因为 ES6 是先新建父类的实例对象<code>this</code>，然后再用子类的构造函数修饰<code>this</code>，使得父类的所有行为都可以继承。下面是一个继承<code>Array</code>的例子；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myArray</span> <span class="keyword">extends</span> <span class="title">Array</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">...arg</span>)</span>&#123;</span><br><span class="line">  	<span class="built_in">super</span>(...arg);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">sum</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 这里的this指自身</span></span><br><span class="line">    <span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;<span class="built_in">this</span>.length;i++)&#123;</span><br><span class="line">    	result += <span class="built_in">parseInt</span>(<span class="built_in">this</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    	<span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> myArray();</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">9</span>;</span><br><span class="line">arr[<span class="number">1</span>] = <span class="number">8</span>;</span><br><span class="line">arr[<span class="number">2</span>] = <span class="number">7</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line"><span class="built_in">console</span>.log(arr.sum());</span><br></pre></td></tr></table></figure>

<p>上面这个例子也说明，<code>extends</code>关键字不仅可以用来继承类，还可以用来继承原生的构造函数。因此可以在原生数据结构的基础上，定义自己的数据结构。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Tom</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2021/10/11/ES6%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/">http://example.com/2021/10/11/ES6语法总结/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">aichihaidilao</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JS/">JS</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/victory-zzm/CDN/img/default_bg2.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/10/15/CSS%E5%88%B7%E9%A2%98%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/victory-zzm/CDN/img/展望.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">CSS刷题查漏补缺</div></div></a></div><div class="next-post pull-right"><a href="/2021/10/09/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/"><img class="next-cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/victory-zzm/CDN/img/default_bg2.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">牛客网刷题总结</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/08/17/Express框架的使用/" title="Express框架的使用"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/victory-zzm/CDN/img/展望.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-17</div><div class="title">Express框架的使用</div></div></a></div><div><a href="/2021/08/12/JS-异步I-O及异步编程/" title="JS-异步I/O及异步编程"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/victory-zzm/CDN/img/default_bg2.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-12</div><div class="title">JS-异步I/O及异步编程</div></div></a></div><div><a href="/2021/08/12/Nodejs学习总结/" title="Nodejs学习总结"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/victory-zzm/CDN/img/展望.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-12</div><div class="title">Nodejs学习总结</div></div></a></div><div><a href="/2021/08/16/Promise和异步函数/" title="Promise和异步函数"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/victory-zzm/CDN/img/default_bg2.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-16</div><div class="title">Promise和异步函数</div></div></a></div><div><a href="/2021/08/14/Nodejs异步编程/" title="Nodejs异步编程"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/victory-zzm/CDN/img/default_bg2.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-14</div><div class="title">Nodejs异步编程</div></div></a></div><div><a href="/2021/07/01/Vue创建项目的注意事项/" title="Vue创建项目的注意事项"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/victory-zzm/CDN/img/default_bg2.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-01</div><div class="title">Vue创建项目的注意事项</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E5%8F%98%E9%87%8F%E7%9A%84%E7%BB%93%E6%9E%84%E8%B5%8B%E5%80%BC"><span class="toc-number">1.</span> <span class="toc-text">1. 变量的结构赋值</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E6%95%B0%E7%BB%84%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 数组的解构赋值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 对象的解构赋值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.3.</span> <span class="toc-text">1.3 解构赋值的作用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E6%89%A9%E5%B1%95"><span class="toc-number">2.</span> <span class="toc-text">2. 运算符的扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E6%8C%87%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6%E3%80%90-%E3%80%91%EF%BC%9A"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 指数运算符【**】：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E9%93%BE%E5%88%A4%E6%96%AD%E8%BF%90%E7%AE%97%E7%AC%A6%E3%80%90-%E3%80%91"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 链判断运算符【?.】</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-NULL-%E5%88%A4%E6%96%AD%E7%AC%A6%E3%80%90-%E3%80%91"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 NULL 判断符【??】</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E9%80%BB%E8%BE%91%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.4.</span> <span class="toc-text">2.4  逻辑赋值运算符</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-Symbol"><span class="toc-number">3.</span> <span class="toc-text">3. Symbol</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-Symbol-prototype-description-%E5%88%9B%E5%BB%BASymbol%E6%97%B6%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E6%8F%8F%E8%BF%B0"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 Symbol.prototype.description(创建Symbol时添加一个描述)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E4%BD%9C%E4%B8%BA%E5%B1%9E%E6%80%A7%E5%90%8D%E7%9A%84Symbol%EF%BC%88%E9%98%B2%E6%AD%A2%E9%87%8D%E5%86%99%EF%BC%89"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 作为属性名的Symbol（防止重写）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-Symbol%E4%BD%9C%E4%B8%BA%E5%B1%9E%E6%80%A7%E5%90%8D%E6%97%B6%EF%BC%8C%E4%B8%8D%E4%BC%9A%E8%A2%ABfor%E2%80%A6in%E3%80%81for%E2%80%A6of%E9%81%8D%E5%8E%86"><span class="toc-number">3.3.</span> <span class="toc-text">3.3 Symbol作为属性名时，不会被for…in、for…of遍历</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-Set%E5%92%8CMap%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">4.</span> <span class="toc-text">4. Set和Map数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-Set%E7%BB%93%E6%9E%84%EF%BC%88%E5%8F%AF%E6%AF%94%E4%BD%9C%E9%9B%86%E5%90%88%EF%BC%89"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 Set结构（可比作集合）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-set%E7%BB%93%E6%9E%84%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 set结构的属性和方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-WeakSet-%E7%BB%93%E6%9E%84%E4%B8%8E-Set-%E7%B1%BB%E4%BC%BC%EF%BC%8C%E4%B9%9F%E6%98%AF%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E5%80%BC%E7%9A%84%E9%9B%86%E5%90%88"><span class="toc-number">4.3.</span> <span class="toc-text">4.3 WeakSet 结构与 Set 类似，也是不重复的值的集合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-Map%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">4.4.</span> <span class="toc-text">4.4 Map数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-1Map%E5%B1%9E%E6%80%A7%E5%92%8C%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95"><span class="toc-number">4.4.1.</span> <span class="toc-text">4.4.1Map属性和操作方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-2-%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95"><span class="toc-number">4.4.2.</span> <span class="toc-text">4.4.2 遍历方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-3-Map%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%85%B6%E5%AE%83%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">4.4.3.</span> <span class="toc-text">4.4.3 Map数据结构与其它数据结构的转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-weakMap%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">4.5.</span> <span class="toc-text">4.5 weakMap数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-1-weakMap%E8%AF%AD%E6%B3%95"><span class="toc-number">4.5.1.</span> <span class="toc-text">4.5.1 weakMap语法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-6-weakRef%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%8C%E7%94%A8%E4%BA%8E%E7%9B%B4%E6%8E%A5%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BC%B1%E5%BC%95%E7%94%A8"><span class="toc-number">4.6.</span> <span class="toc-text">4.6 weakRef数据结构，用于直接创建对象的弱引用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-Proxy-%E4%BB%A3%E7%90%86"><span class="toc-number">5.</span> <span class="toc-text">5. Proxy(代理)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-Proxy%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">5.1.</span> <span class="toc-text">5.1 Proxy实例方法的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-1get-%E6%96%B9%E6%B3%95"><span class="toc-number">5.1.1.</span> <span class="toc-text">5.1.1get()方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-2-set-%E6%96%B9%E6%B3%95"><span class="toc-number">5.1.2.</span> <span class="toc-text">5.1.2 set()方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-2-apply-%E6%96%B9%E6%B3%95"><span class="toc-number">5.1.3.</span> <span class="toc-text">5.1.2 apply()方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-4-has-%E6%96%B9%E6%B3%95"><span class="toc-number">5.1.4.</span> <span class="toc-text">5.1.4 has()方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-Reflect%E7%BB%93%E6%9E%84"><span class="toc-number">6.</span> <span class="toc-text">6.Reflect结构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12-%E7%B1%BB%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">7.</span> <span class="toc-text">12. 类的基本语法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-constructor%E6%96%B9%E6%B3%95"><span class="toc-number">7.1.</span> <span class="toc-text">1. constructor方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B"><span class="toc-number">7.2.</span> <span class="toc-text">2. 类的实例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%B1%BB%E7%9A%84%E5%8F%96%E5%80%BC%E5%87%BD%E6%95%B0-getter-%E5%92%8C%E5%AD%98%E5%80%BC%E5%87%BD%E6%95%B0-setter"><span class="toc-number">7.3.</span> <span class="toc-text">3. 类的取值函数(getter)和存值函数(setter)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Class%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">7.4.</span> <span class="toc-text">4. Class表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="toc-number">7.5.</span> <span class="toc-text">5. 注意点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#this%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98"><span class="toc-number">7.5.1.</span> <span class="toc-text">this指向问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">7.6.</span> <span class="toc-text">6. 类的静态方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#13-%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="toc-number">8.</span> <span class="toc-text">13. 类的继承</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%AE%80%E4%BB%8B"><span class="toc-number">8.1.</span> <span class="toc-text">1.简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Object-getPrototypeOf"><span class="toc-number">8.2.</span> <span class="toc-text">2. Object.getPrototypeOf()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-super%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">8.3.</span> <span class="toc-text">3. super关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%B1%BB%E7%9A%84prototype%E5%92%8C-proto-%E5%B1%9E%E6%80%A7"><span class="toc-number">8.4.</span> <span class="toc-text">4. 类的prototype和__proto__属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-extends%E5%85%B3%E9%94%AE%E5%AD%97%E5%90%8E%E9%9D%A2%E5%8F%AF%E4%BB%A5%E8%B7%9F%E5%A4%9A%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%80%BC"><span class="toc-number">8.5.</span> <span class="toc-text">5. extends关键字后面可以跟多种类型的值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%AE%9E%E4%BE%8B%E7%9A%84-proto"><span class="toc-number">8.6.</span> <span class="toc-text">6. 实例的__proto__</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E5%8E%9F%E7%94%9F%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="toc-number">8.7.</span> <span class="toc-text">7. 原生构造函数的继承</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('https://cdn.jsdelivr.net/gh/victory-zzm/CDN/img/default_bg2.png')"><div id="footer-wrap"><div class="copyright">&copy;2021 By Tom</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a target="_blank" rel="noopener" href="https://butterfly.js.org/">blog</a>!  <a href="icp链接"><span>备案号：xxxxxx</span></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'FdM9DHoaGk6AvEUE4OdbBSmE-MdYXbMMI',
      appKey: '3nvgETGKYL32uuJkv37ewdHI',
      placeholder: '建议使用QQ邮箱，评论头像采用QQ头像',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: false,
      serverURLs: '',
      emojiCDN: 'https://cdn.jsdelivr.net/gh/Artitalk/Artitalk-emoji/bishi.png',
      emojiMaps: {"bilibili22332":"https://valinecdn.bili33.top/bilibili2233/[2233娘_卖萌].png","bilibili22333":"https://valinecdn.bili33.top/bilibili2233/[2233娘_吃惊].png","bilibili22334":"https://valinecdn.bili33.top/bilibili2233/[2233娘_吐魂].png","bilibili22335":"https://valinecdn.bili33.top/bilibili2233/[2233娘_喝水].png","bilibili22336":"https://valinecdn.bili33.top/bilibili2233/[2233娘_困惑].png","bilibili22337":"https://valinecdn.bili33.top/bilibili2233/[2233娘_大哭].png","bilibili22338":"https://valinecdn.bili33.top/bilibili2233/[2233娘_大笑].png","bilibili22339":"https://valinecdn.bili33.top/bilibili2233/[2233娘_委屈].png","bilibili223310":"https://valinecdn.bili33.top/bilibili2233/[2233娘_怒].png","bilibili223311":"https://valinecdn.bili33.top/bilibili2233/[2233娘_无言].png","bilibili223312":"https://valinecdn.bili33.top/bilibili2233/[2233娘_汗].png","bilibili223313":"https://valinecdn.bili33.top/bilibili2233/[2233娘_疑问].png","bilibili223314":"https://valinecdn.bili33.top/bilibili2233/[2233娘_第一].png","bilibili223315":"https://valinecdn.bili33.top/bilibili2233/[2233娘_耶].png","bilibili223316":"https://valinecdn.bili33.top/bilibili2233/[2233娘_郁闷].png","aodamiao1":"https://valinecdn.bili33.top/aodamiao/01.gif","aodamiao2":"https://valinecdn.bili33.top/aodamiao/02.gif","aodamiao3":"https://valinecdn.bili33.top/aodamiao/03.gif","aodamiao4":"https://valinecdn.bili33.top/aodamiao/04.gif","aodamiao5":"https://valinecdn.bili33.top/aodamiao/05.gif","aodamiao6":"https://valinecdn.bili33.top/aodamiao/06.gif","aodamiao7":"https://valinecdn.bili33.top/aodamiao/07.gif","aodamiao8":"https://valinecdn.bili33.top/aodamiao/08.gif","aodamiao9":"https://valinecdn.bili33.top/aodamiao/09.gif","aodamiao10":"https://valinecdn.bili33.top/aodamiao/10.gif","aodamiao11":"https://valinecdn.bili33.top/aodamiao/11.gif","aodamiao12":"https://valinecdn.bili33.top/aodamiao/12.gif","aodamiao13":"https://valinecdn.bili33.top/aodamiao/13.gif","aodamiao14":"https://valinecdn.bili33.top/aodamiao/14.gif","aodamiao15":"https://valinecdn.bili33.top/aodamiao/15.gif","aodamiao16":"https://valinecdn.bili33.top/aodamiao/16.gif","aodamiao17":"https://valinecdn.bili33.top/aodamiao/17.gif","aodamiao18":"https://valinecdn.bili33.top/aodamiao/18.gif","aodamiao19":"https://valinecdn.bili33.top/aodamiao/19.gif","aodamiao20":"https://valinecdn.bili33.top/aodamiao/20.gif","aodamiao21":"https://valinecdn.bili33.top/aodamiao/21.gif","aodamiao22":"https://valinecdn.bili33.top/aodamiao/22.gif","aodamiao23":"https://valinecdn.bili33.top/aodamiao/23.gif","aodamiao24":"https://valinecdn.bili33.top/aodamiao/24.gif","aodamiao25":"https://valinecdn.bili33.top/aodamiao/25.gif","aodamiao26":"https://valinecdn.bili33.top/aodamiao/26.gif","aodamiao27":"https://valinecdn.bili33.top/aodamiao/27.gif","aodamiao28":"https://valinecdn.bili33.top/aodamiao/28.gif","aodamiao29":"https://valinecdn.bili33.top/aodamiao/29.gif","aodamiao30":"https://valinecdn.bili33.top/aodamiao/30.gif","aodamiao31":"https://valinecdn.bili33.top/aodamiao/31.gif","aodamiao32":"https://valinecdn.bili33.top/aodamiao/32.gif","aodamiao33":"https://valinecdn.bili33.top/aodamiao/33.gif","aodamiao34":"https://valinecdn.bili33.top/aodamiao/34.gif","aodamiao35":"https://valinecdn.bili33.top/aodamiao/35.gif","aodamiao36":"https://valinecdn.bili33.top/aodamiao/36.gif","aodamiao37":"https://valinecdn.bili33.top/aodamiao/37.gif","aodamiao38":"https://valinecdn.bili33.top/aodamiao/38.gif","aodamiao39":"https://valinecdn.bili33.top/aodamiao/39.gif","aodamiao40":"https://valinecdn.bili33.top/aodamiao/40.gif","QQ1":"https://valinecdn.bili33.top/QQ/aini.gif","QQ2":"https://valinecdn.bili33.top/QQ/aixin.gif","QQ3":"https://valinecdn.bili33.top/QQ/aoman.gif","QQ4":"https://valinecdn.bili33.top/QQ/baiyan.gif","QQ5":"https://valinecdn.bili33.top/QQ/bangbangtang.gif","QQ6":"https://valinecdn.bili33.top/QQ/baojin.gif","QQ7":"https://valinecdn.bili33.top/QQ/baoquan.gif","QQ8":"https://valinecdn.bili33.top/QQ/bishi.gif","QQ9":"https://valinecdn.bili33.top/QQ/bizui.gif","QQ11":"https://valinecdn.bili33.top/QQ/cahan.gif","QQ12":"https://valinecdn.bili33.top/QQ/caidao.gif","QQ13":"https://valinecdn.bili33.top/QQ/chi.gif","QQ14":"https://valinecdn.bili33.top/QQ/ciya.gif","QQ15":"https://valinecdn.bili33.top/QQ/dabing.gif","QQ16":"https://valinecdn.bili33.top/QQ/daku.gif","QQ17":"https://valinecdn.bili33.top/QQ/dan.gif","QQ18":"https://valinecdn.bili33.top/QQ/deyi.gif","QQ19":"https://valinecdn.bili33.top/QQ/doge.gif","QQ20":"https://valinecdn.bili33.top/QQ/fadai.gif","QQ21":"https://valinecdn.bili33.top/QQ/fanu.gif","QQ22":"https://valinecdn.bili33.top/QQ/fendou.gif","QQ23":"https://valinecdn.bili33.top/QQ/ganga.gif","QQ24":"https://valinecdn.bili33.top/QQ/gouyin.gif","QQ25":"https://valinecdn.bili33.top/QQ/guzhang.gif","QQ26":"https://valinecdn.bili33.top/QQ/haixiu.gif","QQ27":"https://valinecdn.bili33.top/QQ/hanxiao.gif","QQ28":"https://valinecdn.bili33.top/QQ/haobang.gif","QQ29":"https://valinecdn.bili33.top/QQ/haqian.gif","QQ30":"https://valinecdn.bili33.top/QQ/hecai.gif","QQ31":"https://valinecdn.bili33.top/QQ/hexie.gif","QQ32":"https://valinecdn.bili33.top/QQ/huaixiao.gif","QQ33":"https://valinecdn.bili33.top/QQ/jie.gif","QQ34":"https://valinecdn.bili33.top/QQ/jingkong.gif","QQ35":"https://valinecdn.bili33.top/QQ/jingxi.gif","QQ36":"https://valinecdn.bili33.top/QQ/jingya.gif","QQ37":"https://valinecdn.bili33.top/QQ/juhua.gif","QQ38":"https://valinecdn.bili33.top/QQ/keai.gif","QQ39":"https://valinecdn.bili33.top/QQ/kelian.gif","QQ40":"https://valinecdn.bili33.top/QQ/koubi.gif","QQ41":"https://valinecdn.bili33.top/QQ/ku.gif","QQ42":"https://valinecdn.bili33.top/QQ/kuaikule.gif","QQ43":"https://valinecdn.bili33.top/QQ/kulou.gif","QQ44":"https://valinecdn.bili33.top/QQ/kun.gif","QQ45":"https://valinecdn.bili33.top/QQ/lanqiu.gif","QQ46":"https://valinecdn.bili33.top/QQ/leiben.gif","QQ47":"https://valinecdn.bili33.top/QQ/lenghan.gif","QQ48":"https://valinecdn.bili33.top/QQ/liuhan.gif","QQ49":"https://valinecdn.bili33.top/QQ/liulei.gif","QQ50":"https://valinecdn.bili33.top/QQ/nanguo.gif","QQ51":"https://valinecdn.bili33.top/QQ/OK.gif","QQ52":"https://valinecdn.bili33.top/QQ/penxue.gif","QQ53":"https://valinecdn.bili33.top/QQ/piezui.gif","QQ54":"https://valinecdn.bili33.top/QQ/pijiu.gif","QQ55":"https://valinecdn.bili33.top/QQ/qiang.gif","QQ56":"https://valinecdn.bili33.top/QQ/qiaoda.gif","QQ57":"https://valinecdn.bili33.top/QQ/qinqin.gif","QQ58":"https://valinecdn.bili33.top/QQ/qiudale.gif","QQ59":"https://valinecdn.bili33.top/QQ/quantou.gif","QQ60":"https://valinecdn.bili33.top/QQ/saorao.gif","QQ61":"https://valinecdn.bili33.top/QQ/se.gif","QQ62":"https://valinecdn.bili33.top/QQ/shengli.gif","QQ63":"https://valinecdn.bili33.top/QQ/shouqiang.gif","QQ64":"https://valinecdn.bili33.top/QQ/shuai.gif","QQ65":"https://valinecdn.bili33.top/QQ/shui.gif","QQ66":"https://valinecdn.bili33.top/QQ/tiaopi.gif","QQ67":"https://valinecdn.bili33.top/QQ/touxiao.gif","QQ68":"https://valinecdn.bili33.top/QQ/tu.gif","QQ69":"https://valinecdn.bili33.top/QQ/tuosai.gif","QQ70":"https://valinecdn.bili33.top/QQ/weiqu.gif","QQ71":"https://valinecdn.bili33.top/QQ/weixiao.gif","QQ72":"https://valinecdn.bili33.top/QQ/woshou.gif","QQ73":"https://valinecdn.bili33.top/QQ/wozuimei.gif","QQ74":"https://valinecdn.bili33.top/QQ/wunai.gif","QQ75":"https://valinecdn.bili33.top/QQ/xia.gif","QQ76":"https://valinecdn.bili33.top/QQ/xiaojiujie.gif","QQ77":"https://valinecdn.bili33.top/QQ/xiaoku.gif","QQ78":"https://valinecdn.bili33.top/QQ/xiaoyanger.gif","QQ79":"https://valinecdn.bili33.top/QQ/xieyanxiao.gif","QQ80":"https://valinecdn.bili33.top/QQ/xigua.gif","QQ81":"https://valinecdn.bili33.top/QQ/xu.gif","QQ82":"https://valinecdn.bili33.top/QQ/yangtuo.gif","QQ83":"https://valinecdn.bili33.top/QQ/yinxian.gif","QQ84":"https://valinecdn.bili33.top/QQ/yiwen.gif","QQ85":"https://valinecdn.bili33.top/QQ/youhengheng.gif","QQ86":"https://valinecdn.bili33.top/QQ/youling.gif","QQ87":"https://valinecdn.bili33.top/QQ/yun.gif","QQ88":"https://valinecdn.bili33.top/QQ/zaijian.gif","QQ89":"https://valinecdn.bili33.top/QQ/zhayanjian.gif","QQ90":"https://valinecdn.bili33.top/QQ/zhemo.gif","QQ91":"https://valinecdn.bili33.top/QQ/zhouma.gif","QQ92":"https://valinecdn.bili33.top/QQ/zhuakuang.gif","QQ93":"https://valinecdn.bili33.top/QQ/zuohengheng.gif"},
      enableQQ: false,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.17.0/js/md5.min.js"></script><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getIcon = (icon, mail) => {
    if (icon) return icon
    let defaultIcon = '?d=monsterid'
    let iconUrl = `https://gravatar.loli.net/avatar/${md5(mail.toLowerCase()) + defaultIcon}`
    return iconUrl
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'data-lazy-src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }

        result += `<div class='content'>
        <a class='comment' href='${array[i].url}'>${array[i].content}</a>
        <div class='name'><span>${array[i].nick} / </span><time datetime="${array[i].date}">${btf.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom.innerHTML= result
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const getComment = () => {
    const serverURL = 'https://FdM9DHoa.api.lncldglobal.com'

    var settings = {
      "method": "GET",
      "headers": {
        "X-LC-Id": 'FdM9DHoaGk6AvEUE4OdbBSmE-MdYXbMMI',
        "X-LC-Key": '3nvgETGKYL32uuJkv37ewdHI',
        "Content-Type": "application/json"
      },
    }

    fetch(`${serverURL}/1.1/classes/Comment?limit=6&order=-createdAt`,settings)
      .then(response => response.json())
      .then(data => {
        const valineArray = data.results.map(function (e) {
          return {
            'avatar': getIcon(e.QQAvatar, e.mail),
            'content': changeContent(e.comment),
            'nick': e.nick,
            'url': e.url + '#' + e.objectId,
            'date': e.updatedAt,
          }
        })
        saveToLocal.set('valine-newest-comments', JSON.stringify(valineArray), 10/(60*24))
        generateHtml(valineArray)
      }).catch(e => {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.innerHTML= "无法获取评论，请确认相关配置是否正确"
      }) 
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('valine-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><div class="aplayer no-destroy" data-id="6751706134" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-preload="none" data-autoplay="true" muted></div><script defer src="/live2d-widget/autoload.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><script src="//code.tidio.co/jalt1ldr3kezdt1i6b8q3ptyqeesey5e.js" async="async"></script><script>function onTidioChatApiReady() {
  window.tidioChatApi.hide();
  window.tidioChatApi.on("close", function() {
    window.tidioChatApi.hide();
  });
}
if (window.tidioChatApi) {
  window.tidioChatApi.on("ready", onTidioChatApiReady);
} else {
  document.addEventListener("tidioChat-ready", onTidioChatApiReady);
}

var chatBtnFn = () => {
  document.getElementById("chat_btn").addEventListener("click", function(){
    window.tidioChatApi.show();
    window.tidioChatApi.open();
  });
}
chatBtnFn()
</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = [
  'title',
  '#config-diff',
  '#body-wrap',
  '#rightside-config-hide',
  '#rightside-config-show',
  '.js-pjax'
]

if (false) {
  pjaxSelectors.unshift('meta[property="og:image"]', 'meta[property="og:title"]', 'meta[property="og:url"]')
}

var pjax = new Pjax({
  elements: 'a:not([target="_blank"]):not([href="/music/"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener toc scroll 
  window.removeEventListener('scroll', window.tocScrollFn)

  typeof preloader === 'object' && preloader.initLoading()
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // Analytics
  if (false) {
    MtaH5.pgv()
  }

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>